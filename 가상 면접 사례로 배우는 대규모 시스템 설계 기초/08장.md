# 8장 URL 단축기 설계

## 문제 이해 및 설계 범위 확정

- 긴 URL을 짧게 줄인다
- 축약된 URL로 HTTP 요청이 오면 원래 URL로 안내
- 높은 가용성과 규모 확장성, 장애 감내 요구

### 개략적 추정

(와... 이렇게 추정한다고)

- 매일 1억개의 쓰기연산
- 초당 쓰기 연산 -> 1억 / 24 / 3600 = 1160회
- 읽기 연산: 읽기 연산과 쓰기 연산의 비율은 10:1 -> 읽기 연산은 초당 11600회
- 10년 운영: 1억 * 365 * 10 = 3650억개 레코드 보관
- URL평균 길이는 100
- 3650억 * 100바이트 = 36.5TB

### 개략적 설계안 제시 및 동의 구하기

**API 엔드포인트**

```
POST /api/v1/data/shorten
{
  longUrl: "url"
}
```

```
GET /api/v1/shortUrl
```

- GET 요청을 보낼 경우 원래 URL을 301 상태로 리턴한다

**301, 302 응답 차이**

- 301 Permanently Moved
  - 영구적으로 URL이 이전되었다
  - 브라우저는 이 응답을 캐시한다!!
  - 서버 부하를 줄일 수 있다
- 302 Found
  - 일시적으로 URL이 이전되었다
  - 클라이언트 요청은 단축 URL 서버에 먼저 보내진 다음에 원래 URL로 리다이렉션 되어야 한다
  - 무조건 서버를 들렸다 가므로 트래픽 분석을 할 수 있다!!
  - 클릭 발생률이나 발생 위치를 추적이 가능하다

### URL 단축

- 긴 URL -> 해시함수 -> 짧은 URL
- 긴 URL이 다른 값이면 해시 값도 달라져야 한다
- 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야 한다

### 상세 설계

- 데이터모델
- 관계형 데이터베이스 사용
- PK(id), shortUrl, longUrl

### 해시 함수

- 해시값 길이
- [0-9, a-z, A-Z] 문자들
- 10 + 26 + 26 = 62개의 문자
- 62^n >= 3650억인 n의 최솟값을 찾아야 한다, n은 문자 길이
- n = 7이면 3.5조 개의 URL을 만들 수 있다
- 짧은 URL의 길이는 7

### 해시 함수 구현 - 해시 후 충돌해소

- CRC32, MD5, SHA-1같은 유명한 해시 함수 사용
- 결과로 7글자를 맞춰야 한다
- 앞의 7글자만 사용하고 충돌날 경우 "기존URL + 특정문자열" 더해서 다시 해싱
- 이미 저장된 값인지 확인하기 위해 디비에 여러번 접근해야 한다
- 데이터베이스 대신 블룸필터를 사용하면 성능을 높일 수 있다
- 해시값이 이미 있는 값인지 확인을 빠르게 하기 위해서 블룸필터를 쓰는 듯

### 해시 함수 구현 - base-62 변환

- 62진법으로 변환한다
- hashValue로 사용할 수 있는 문자가 62개여서 62진법
- a는 10, Z는 61
- 11157은 2TX
- column의 id 값을 62진법으로 변환한 값은 shortenURL로 사용한다

### 해시 후 충돌해소 vs base62

- 해시 후 충돌해소
  - 단축 URL 길이가 7자리로 고정됨
  - 충돌이 가능해서 충돌 해소 전략 필요
- base62
  - 유일성이 보장되는 ID 생성기가 필요
  - URL 길이가 가변적, ID가 커지면 길이가 길어짐
  - ID의 유일성이 보장되어야 사용가능, 충돌이 일어날 일은 없다
  - ID가 1씩 증가하는 값이라면 다음에 쓸 수 있는 URL이 무엇인지 쉽게 파악 가능
