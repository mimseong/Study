# 16.4 복제 데이터 포맷

- 변경 이벤트가 바이너리 로그에 어떤 형태로 저장 되는지 알아보자
- Statement 형식: 실행된 SQL문을 기록
- Row 형식: 변경된 데이터 자체를 기록
- mysqlbinlog: 바이너리 로그를 사람이 읽을 수 있는 형태로 변환

## statement 포맷

- SQL 하나만 기록
- 장점
	- 용량이 작다
	- 복제가 빠르다
	- 감사 목적으로 사용 가능
- 단점
	- 비확정적 쿼리인 경우
	- 데이터 일관성을 해칠 수 있다
	- 그래서 트랜잭션 격리 수준을 REPEATABLE-READ 이상이어야 한다
	- 데이터 락 점유 시간이 길다
	- 소스 서버에 락을 많이 건 쿼리 실행 -> 레플리카에도 똑같이 실행

## row 포맷

- 변경된 값 자체가 바이너리 로그에 기록
- 모든 트랜잭션 격리 수준에서 사용 가능
- 사용자 계정 생성, 권한 부여 및 회수, 테이블 뷰, 트리거 생성과 같은 DDL은 statement 포맷으로 저장
- 장점
	- 소스서버 <-> 레플리카 서버 간의 데이터 일관성 유지 가능
	- 5.7.7부터 기본 포맷
	- 비확정적 함수 사용 OK, 안전 복제 가능
	- statement보다 락이 적다
- 단점
	- 변경된 데이터가 많거나 클 경우 바이너리 로그 파일 크기 크다
	- 원본 쿼리 보려면 mysqlbinlog 사용

## Mixed 포맷

- 기본적으로는 statement 포맷
- 비확정적 쿼리는 row 포맷

## Row 포맷의 용량 최적화

- 변경 데이터의 칼럼을 전부 저장할 것인지, 쿼리문에서 명시된 칼럼만 저장할 것인지 옵션 설정 가능
- 변경 데이터 압축해서 바이너리 로그 기록
- 소스와 레플리카 서버 둘 다 8.0.20 버전 이상이어야 한다
- 압축은 세션별로 설정 가능하다
- 압축 된 것과 안 된 것 혼합해도 문제 없다

## 복제 동기화 방식

- 비동기 복제
	- 변경 이벤트가 잘 적용되었는지 확인하지 않는다
	- 장애가 났을 경우 레플리카에 어디까지 적용됐는지 알지 못한다
	- 조금 더 빠른 성능
	- 레플리카에 문제 생겨도 소스 서버는 영향 X
	- 레플리카 여러 대 연결해도 큰 성능 저하 X
- 반동기 복제
- AFTER_SYNC
	- 레플리카로부터 ACK를 받아야 트랜잭션 커밋하고 결과 반환
	- 전송을 보장, 적용을 보장하는 건 아님
- AFTER_COMMIT
	- 커밋까지 하고나서 레플리카로 이벤트 발송
	- 팬텀 리드 발생할 수 있다
- 반동기라해서 무작정 기다리는 건 아니다
- 타임아웃 설정 가능
- 응답 받아야 하는 레플리카 서버 수 설정 가능

